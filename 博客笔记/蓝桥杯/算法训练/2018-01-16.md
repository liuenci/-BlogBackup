---
date: 2018-01-16 10:31
status: public
title: 'ALGO-2    最大最小公倍数'
---

题目如下：
![](http://ove4nglsb.bkt.clouddn.com/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0.png)
代码如下：
```java
import java.util.Scanner;

public class TheMaxCommonNum {

	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		long n = input.nextLong();

		long result1 = n * (n - 1) * (n - 2);
		long result2 = n * (n - 1) * (n - 3);
		long result3 = (n - 1) * (n - 2) * (n - 3);
		input.close();
		if (n == 1) {
			System.out.println(1);
		} else if (n == 2) {
			System.out.println(2);
		} else {
			if (n % 2 != 0) {
				System.out.println(result1);
			}else {
				if(n%3!=0) {
					System.out.println(result2);
				}else {
					System.out.println(result3);
				}
			}
		}
	}
}
```
解题思路如下：
这道题用到了贪心算法，将大规模的数据分解成小块的数据去解题
如果n、n-1和n-2三个数两两互质的话，那么结果就是这三个数的积。
我们可以知道，当n是奇数时，n 和n-2都是奇数，n-1是偶数,那么他们三个的公约数肯定不是2,而因为这三个数是连续的，所以大于2的数都不可能成为他们或其中任意两个数的公约数了.结果就是他们三个的乘积.
而当n为偶数时，n*(n-1)*(n-2)肯定不行了，因为n和n-2都是偶数，那么只能将n-2改成n-3，即n*(n-1)*(n-3),如果这三个数两两互质那么肯定就是结果了.
但是因为n和n-3相差3,所以当其中一个数能被3整除时，另一个肯定也可以.而当其中一个不可以时，另一个肯定也不可以.而因为n为偶数,n-3为奇数，所以2不可能成为他俩的公因子。对于大于3的数，肯定就都不可能成为这三个数或者其中任意两个数的公约数了.因此只需再对3进行判断：
如果n能整除3，那么，n*(n-1)*(n-3)就肯定不行了，因为n和n-3有了公约数3，结果肯定小了，那么就只能继续判下一个即n*(n-1)*(n-4)而这样n-4又是偶数，不行，继续下一个n*(n-1)*(n-5) = n^3 -6*n^2 + 5*n 而如果这个可以 那个其值肯定要小于(n-1)*(n-2)*(n-3) = n^3 -6*n^2+11n-6(对于n>1来说都成立),而(n-1)*(n-2)*(n-3)由上一个奇数结论可知是一个符合要求的，因此到n-5就不用判断了。直接选答案为(n-1)*(n-2)*(n-3)；
而n不能整除3，那么结果就是n*(n-1)*(n-3)，因为n和n-3都不能整除3,此时n-1能不能整除3都无关紧要了.而对于其它数 都是不可能的.上面已证.
简单的提炼一下，先判断n是不是奇数 ，如果是  直接输出n*(n-1)*(n-2)  否则判断n能不能被3整除，如果不能，输出n*(n-1)*(n-3)，否则输出(n-1)*(n-2)*(n-3) 

首先要写n=1和n=2的情况，即使你不写，也会是满分，因为测试数据中没有1和2.

以上是参考的百度一位同学的解释，自己模拟着解释了一遍，为了保护原创，原文链接如下：
http://blog.csdn.net/qq_34594236/article/details/51178164
1. 如果是奇数，那么最大最小公倍数就是n*(n-1)*(n-2);
2. 如果是偶数，那么n*(n-1)*(n-2)就不是最大最小公倍数，因为n和(n-2)有公约数2，如果n不能被3整除，则最大最小公倍数是n*(n-1)*(n-3)，如果能被3整除，那么最大最小公倍数就不是n*(n-1)*(n-3)，所以换成n*(n-1)*(n-4),但是n和n-4有公约数2,所以又推到n*(n-1)*(n-5),但是n*(n-1)*(n-5)对于n>1的数来说肯定要小于(n-1)*(n-2)*(n-3),因为(n-1)是奇数了，所以满足条件就是最大最小公倍数。                                                        