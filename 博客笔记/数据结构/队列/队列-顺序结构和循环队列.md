#### 什么是队列
队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

换个意思说，队列是一种先进先出的的线性表，简称FIFO.允许插入的一端称为队尾，允许删除的一端叫做队头。

#### 队列的实际应用
键盘的输入，到显示器上记事本软件的输出都是队列的应用。

#### 队列顺序存储的不足
顺序存储使用数组来存储队列的元素，队列的添加就是在队尾追加一个元素，这个时候不需要移动任何元素，时间复杂度为o(1),但是队列删除元素是在队头，即是下标为0的位置，那也就意味着队列中的所有元素都得向前移动一位，因此时间复杂度为o(n)，但是这样子性能就会特别的差，因此我们想到了更好的解决方案。

那就是引入 front 和 rear 指针，front 指针指向队头元素，rear 指向队尾元素的下一个位置，当 front 等于 rear 时，队列为空。

但是这样子就会出现假溢出的问题。

假设是长度为 5 的数组，初始状态下，front 和 rear 都指向下标为 0 的位置，然后入队 a1,a2,a3,a4. 这时候 front 指针仍然指向 0 ，而 rear 指针指向 4,。

然后出对 a1,a2, front 指向 2,rear 不变。

这时候入队 a5,front 指针不变，但是 rear 会指向数组之外。

如果再入队 a6，就会发生数组越界的错误，但是 0 和 1 两个位置上还是空闲的，这种现象就是假溢出现象。

#### 循环队列
解决假溢出的方法就是当后面满了，再从头开始入队，也就是头尾相接的循环。我们把这种头尾相接的顺序存储结构称为循环队列。

#### 循环队列解决队列顺序存储的不足
从入队 a5 开始讲起，front 指针不变，rear 指向 0.

接着入队 a6,队列满，这时候 front == rear。

前面我们说到 front == rear 是队列空。但是此时是队列慢，那么如何判断一个循环队列是空队列还是满队列呢？

这里我们创建数组的大小需要在预先设计的数组大小加 1，当队列为空时，条件就是 front == rear,当队列满时，数组中还有一个空闲的单位。
通过规律可以得到队列中的长度元素为
```
(rear - front + arraySize) % arraySize
```
如果
```
(rear + 1) % arraySize = front
```
则队列满。
如果
```
front == rear
```
则队列空。

#### 关于代码
关于队列的坑估计就是上面这些了，如果想了解详细的源码可以前往我的 github 地址详细了解。
github : https://github.com/liuenci/Data-Structure
